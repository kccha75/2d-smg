% Performs multiplication L*u using Cheb-Fourier collocation methods
% L is the spectral operator for the given PDE in the form
% au_xx+bu_yy+cu=f
%
% Inputs:
% v - best estimate
% pde.a
% pde.b
% pde.c
% domain.k - wave number
%
% Ouputs:
% A - L*u
%
function f=Lu_2d(v,pde,domain)

k=domain.k;

a=pde.a;
b=pde.b;
c=pde.c;

u=cell(2);
u{1}=v;
u{2}=v';

for i=1:domain.dim
    
    switch domain.discretisation(i)
        
        case 1 % Fourier
            
            % 1D u_xx
            Lu{i}=real(ifft(-k{i}.^2.*fft(u{i})));
            
        case 2 % Cheb
            
            % 1D u_xx
            Lu{i}=ifct(chebdiff(fct(u{i}),2));
    end
    
    
end

% Compute au_xx+bu_yy+cu
f=a.*Lu{1}+b.*Lu{2}'+c.*v;

% -------------------------------------------------------------------------
% Apply BCs
% -------------------------------------------------------------------------

[I,J]=ndgrid(1:N(1),1:N(2));
index=cell(length(domain.BCflag));

% Find indices of boundary
index{1}=sub2ind(N,I(:,1),J(:,1)); % Left boundary of matrix
index{2}=sub2ind(N,I(:,end),J(:,end)); % Right boundary of matrix
index{3}=sub2ind(N,I(1,:),J(1,:)); % Top boundary of matrix
index{4}=sub2ind(N,I(end,:),J(end,:)); % Bottom boundary of matrix

% Dirichlet -1 boundary
f(end,:)=v(end,:);
% Neumann +1 boundary
f(1,:)=sum(fct(v).*k{1}.^2);


for i=1:length(domain.BCflag)
    
    switch domain.BCflag(i)
        
        
        case 1 % Dirichlet
            f(index{i})=v(index{i});
            
        case 2 % Neumann
            
            f(index{i})=sum(fct(v).*k{1}.^2);
            
            
        case 3 % Fourier

        
    end
    
end

end