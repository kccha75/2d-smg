clear;close all
% -------------------------------------------------------------------------
% Solve KP using Newton's method in the form (-u_xx+au_x+bu+cu^2)_xx+du_yy=f_xx
% Note: there is a problem if coarsestgrid is 6 or lower 
% 
% -------------------------------------------------------------------------
% INPUT PARAMETERS
% -------------------------------------------------------------------------
L(1) = 10 * pi;
L(2) = 10 * pi;
finestgrid = 8;
coarsestgrid = 7;

% PDE parameters

a=@(X,Y) 0;
b=@(X,Y) 0;
c=@(X,Y) 3;
d=@(X,Y) 1;

% RHS function
f=@(X,Y) 8*(-2*sech(X).^4+4*sech(X).^2.*tanh(X).^2);

% Initial guess
v0=@(X,Y) 2*sech(X).^2;

% -------------------------------------------------------------------------
% Set up parameters
% -------------------------------------------------------------------------
N(1) = 2^finestgrid;
N(2) = 2^finestgrid;

% Spectral Wave numbers
k(:,1) = 2*pi/L(1)*[0:N(1)/2-1 -N(1)/2 -N(1)/2+1:-1]';
k(:,2) = 2*pi/L(2)*[0:N(2)/2-1 -N(2)/2 -N(2)/2+1:-1]';
[KX,KY] = ndgrid(k(:,1),k(:,2));

x(:,1) = L(1)*(-N(1)/2:N(1)/2-1)'/N(1);
x(:,2) = L(2)*(-N(2)/2:N(2)/2-1)'/N(2);
[X,Y] = ndgrid(x(:,1),x(:,2));

a=a(X,Y);
b=b(X,Y);
c=c(X,Y);
d=d(X,Y);
f=f(X,Y);

v0=v0(X,Y);

% -------------------------------------------------------------------------
% Multigrid Options here
% -------------------------------------------------------------------------

% Number of V-cycles if option is chosen, otherwise number of v-cycles done
% after FMG
option.num_vcycles=100;

% Solver / solution tolerance
option.tol=1e-12;

% Relaxations on the up and down cycle during Multigrid
option.Nd=1;
option.Nu=1;

% Multigrid solver options:'V-cycle' or 'FMG'
option.solver='FMG';

% Multigrid scheme: 'Correction' or 'FAS'
option.mgscheme='Correction';

% Operator, coarse grid solver, Relaxation, Restriction, Prolongation options
option.operator=@fourier_Lu_2d_mid;
option.coarsegridsolver=@cg;
option.relaxation=@MRR;
option.restriction=@fourier_restrict_2d_mid;
option.prolongation=@fourier_prolong_2d_mid;

% Preconditioner
option.preconditioner=@fourier_yang_pre_2d;
% Number of precondition relaxations
option.prenumit=1;

% -------------------------------------------------------------------------
% Sort into sctructures
% -------------------------------------------------------------------------
% Assuming constant dx
dx(1) = x(2,1)-x(1,1);
dx(2) = x(2,2)-x(1,2);

% Sort into structures
domain.L = L;
domain.N = N;
domain.k = k;
domain.dx = dx;

pde.a = a;
pde.b = b;
pde.c = c;
pde.d = d;
pde.f = f;

option.finestgrid=finestgrid;
option.coarsestgrid=coarsestgrid;
option.grids=finestgrid-coarsestgrid+1;

% -------------------------------------------------------------------------
% NEWTON HERE
% -------------------------------------------------------------------------

% 1d options
option1d=option;
option1d.operator=@fourier_Ku_1d;
option1d.coarsegridsolver=@fourier_matrixsolve_1d;
option1d.relaxation=@MRR;
option1d.restriction=@fourier_restrict_filtered;
option1d.prolongation=@fourier_prolong_filtered;

% Initial guess
v=v0;

% Jacobian here (linearized equation)
bnew=b+2*c.*v0;

% Initial error guess
e0=zeros(N);

tic
for i=1:20
    
    pde.b=b;
    
    % Initial RHS of linear equation (nonlinear residual)
    pfe.f=f-(option.operator(v,pde,domain));
    
    r=rms(rms(pde.f));
    fprintf('Residual Newton = %d\n',r)
    if r<=1e-10
        fprintf('Converged after %d Newton Iterations \n',i-1)
        break
    end
    
    % Solve Newton iteration (fixed point)
    % 1D slices

    pde.f=pde.f-e0;
    for ii=1:N(1)
        
        pde1.a=a;
        pde1.b=bnew(:,ii);
        pde1.c=c;
        pde1.d=d;
        pde1.f=pde.f(:,ii);
        
        % Solve linear equation
        pde.c=0;
%         e=mg(e0,pde,domain,option1d);
        e=fourier_matrixsolve_1d(e0,pde1,domain,option1d);

    
    end
    
           
    % Linear part
	lin(:,ii)=-option1d.operator(e,pde,domain);
        
	% Nonlinear part
	pde.c=c;
        nonlin=f-option.operator(v,pde,domain);
        
        % Final e
        e=1/pde.c*ifft(-k(:,2).^2.*fft(nonlin+lin));
    
    v=v+e;
    bnew=b+2.*c.*v;

    
    % Update Jacobian


end

if i==20
    
    fprintf('Did not converge to required tolerance after %d Newton Iterations\n',i)
    
end 

